// 배열
    int[] array = new int[5];
    array[0] = 10;
    array[1] = 20;
    array[2] = 30;
    array[3] = 40;
    array[4] = 50;

    int[] array2 = new int[] { 10, 20, 30 };
    int[] array3 = new int[5] { 10, 20, 30, 40, 50 };
    
    // 동일한 자료형을 가진 데이터들을 연속적인 메모리에 저장하여 인덱스로 접근할 수 있게 된다.
    // new 키워드를 사용하여 동적으로 할당 받는 배열을 만들 수 있다. (동적으로 할당 받았다고해서 동적 배열인 것은 아님.
    // 동적 배열은 크기가 가변적인 배열을 의미. 동적으로 할당, 즉 힙 메모리에 할당 받았을 뿐 크기를 바꿀 수 없는 정적 배열이다.)
    
    // 배열을 동적으로 할당 받으므로(배열 데이터가 힙메모리에 있으므로) 동일한 배열 메모리를 가리키는 변수가 여러개일 수도 있다. Call by Reference
    int[] array = new int[5] { 10, 20, 30, 40, 50 };
    int[] array2 = array;
    
    // new를 생략하는 것도 가능하다. 그래도 두 변수가 동일한 배열 메모리를 가리킬 수 있는 것을 보면 동적으로 할당(힙 메모리로) 받는 것 같다.
    // C#은 C++과 달리 배열이 무조건 힙 메모리에 존재하게 되어 있다. 즉 무조건 동적으로 할당 받음.
    int[] array = { 10, 20, 30 };
    int[] array2 = array;
    
    // 크기를 한번 선언하면 바꿀 수 없다.
    // 배열크기를 벗어나는 인덱스로 배열에 접근하면 런타임 에러가 발생한다.
    
    // foreach문
    foreach (var element in array)
        Console.Write(element);
    // 특정 자료구조 전체를 순회하며 돌때는 foreach문이 낫다. 가독성도 좋고 인덱스 번호 실수할 일도 없고.
    
    
    // 다차원 배열
    int[,] arr = new int [2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };   // [a,b] 집합 a개 집합마다 b만큼의 원소가 있음
    int[,] arr2 = new int[,] { { 1, 2, 3 }, { 4, 5, 6 } };
    int[,] arr3 = { { 1, 2, 3 }, { 4, 5, 6 } };

    arr[0, 0] = 1;     // arr의 0번째 집합의 0번째 원소 1
    arr[1, 2] = 6;     // arr의 1번째 집합의 2번째 원소 6
    
    for(int i=0; i<arr.GetLength(0); i++)
        for(int j=0; j<arr.GetLength(1); j++) 
    
    
    // C#에선 arr[a,b] 이런식으로도 표현 가능.
    // 물론 arr[a][b] 표현도 가능.
    
    // 다차원 배열에선 GetLength로 쓰자.
    
    // arr.Length()  배열의 전체 원소개수.  2*3 = 6
    // arr.GetLength(0)   행의 개수  2
    // arr.GetLenght(1)   열의 개수  3
    
    
    int [][] a new int[3][];
    a[0] = new int[3];
    a[1] = new int[6];
    a[2] = new int[2];

    a[0][0] = 1;

    // 위와 같이 열의 크기를 나중에 정할 수도 있다. 행마다 배열의 크기가 다르게도 할 수 있다.
