CLR은 메모리에 어떤 객체를 할당하기 위해 일정 크기의 메모리를 확보한다.

메모리 공간을 통째로 확보해서 하나의 관리되는 힙(Managed Heap)을 생성한다. 그리고 힙의 첫번째 주소에 "다음 객체를 할당할 포인터"를 위치시킨다. (현재는 0번)

0 1 2 3 4 5 6 ... 이런식으로 메모리가 구성되어 있다고 가정하고 여기에 맨 처음 객체를 할당해보자.

Object A = new object();
이렇게 되면 0의 위치에 A를 할당하고 포인터는 1의 위치로 이동하게 된다.

같은 방법으로 Object B = new object(); 를 실행하면 1의 자리에 B가 할당되고 포인터는 2로 이동한다.

CLR은 객체가 위치할 메모리를 할당하기위해 메모리 공간을 쪼개 만든 연결 리스트를 탐색하는 시간과재조정하는 작업도 필요하지 않다. 그저 메모리만 할당할 뿐이다.

Q. 그렇다면 언제 어떻게 메모리에서 해제되는가? 일단 쓰레기인지 아닌지 파악하는 게 우선이다..


if (true{
      Object a = new object();
}

객체의 내용물은 힙에 저장되고, A가 위치한 힙 메모리 주소는 a에 있다.


a .........(아직 메모리 주소 비어있음)   (스택.  주소)

A ..........            (관리되는 힙. 객체 내용물)




........... (메모리 주소 a 없어짐)
A.......... (객체인 A만 남게 됨)



if문이 끝나면 주소인 a가 사라진다. 이 경우 A는 이제 코드의 어디에서도 접근할 수 없기 때문에 더 이상 사용할 수 없게 되었다. 
즉 쓰레기가 되고, 가비지 컬렉터가 집어가게 된다.






a와 같이 할당된 메모리의 위치를 참조하는 객체를 루트라고 한다. 
루트는 a의 경우처럼 스택에 생성될 수도 있고 정적 필드처럼 힙에 생성될 수도 있다.
NET 에플리케이션이 실행되면jit 컴파일러가 이 루트들을 목록으로 만들고, CLR은 이 루트 목록을관리하며 상태를 갱신한다. 
이 루트가 중요한 이유는 가비지 컬렉터가CLR이 관리하고 있던 루트 목록을 참조해서 쓰레기를 수집하기 때문이다.





1. 작업을 시작하기 전에, 가비지 컬렉터는 모든 객체를 쓰레기라고 가정한다. 루트 목록 내의 어떤 루트도 메모리를 가지지 않는다고 가정한다.
2. 루트 목록을 순회하면서 각 루트가 참조하고 있는 힙 객체와의 관계 여부를 조사한다. 루트가 참조하고 있는 힙의 객체가 또 다른 힙 객체를 참조하고 있으면 이 역시 해당 루트와 관계있는
것으로 판단한다. 어떤 루트와도 관계가 없으면 쓰레기로 간주한다.
3. 쓰레기 객체가 차지하고 있는 공간은 이제 "비어있는 공간"이다.
4. 루트 목록에 대한 조사가 끝나면, 가비지 컬렉터는 이제 힙을 순회하면서 쓰레기가 차지하고 있던 "비어있는 공간"에 쓰레기의 인접객체들을 이동시켜 차곡차곡 채워 넣는다.
