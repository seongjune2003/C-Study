    // 객체 지향
    class Knight
    {
        public int hp;
        public int attack;

        public Knight Clone()
        {
            Knight knight = new Knight();
            knight.hp = hp;
            knight.attack = attack;
            return knight;
        }
        
        public void Move()
        {
            Console.Write("Knight Move");
        }

        public void Attack()
        {
            Console.Write("Knight Attack");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight();

            knight.hp = 100;
            knight.attack = 10;
            knight.Move();
            knight.Attack();
        }
    }

    
    //여기서 Knight knight 만으로는 객체생성 안됨. struct는 그렇게 해도 메모리 할당 되는데 클래스는 new로 새 인스턴스 생성해줘야 함.
    //new를 사용해 할당했다는 건 힙 메모리에 동적으로 할당한 받았다는 것. C#은 C++랑 다르게 무조건 힙 메모리에 올라감.(C++은 구조체, 클래스 모두 스택(선입선출), 힙(후입선출) 양쪽다 사용가능)
    // 힙과 다르게 스택 메모리는 유효범위가 계속 달라짐. 스택의 주소를 참조하는 건 조금 위험함.
    
    // 만약 참조가 아닌 깊은 복사가 목적이면
    //Knight knight2 = knight.Clone();
    //새로운 별개의 객체를 생성하여 자기 자신의 속성 값들을 복사하고 이를 리턴하는 함수 Clone()을 만든다. 직접 Call by Value를 구현하는 방식.
    
스택 메모리
    불완전하고 일시적으로 사용하는 메모리
    메모장 같은 존재.
        함수 내부에서만 살아 있다가 함수 끝나면 사라지는 지역 변수, 연쇄적인 함수들의 호출 위치 등등 잠깐 있다 사라질 것들은 스택 메모리에 올라온다.
        스택 자료구조처럼 쌓이는 구조고 가장 나중에 쌓인게 가장 먼저 빠진다.
        반면에 객체와 같은 Call by Reference 는 스택 메모리에 그 데이터 자체가 아닌 그 데이터가 있는 주소가 올라간다.
        실제 데이터는 힙 메모리에 있다. 즉 스택 메모리에 저장되는건 본체 데이터가 위치한 힙 메모리의 주소다.
    
    힙 메모리
new 등등 프로그램 실행 中 실시간으로 할당 된 것들이 올라간다.
실행 전부터 메모리를 잡고 실행하는 것이 아니라 프로그램 실행 중에 그때 그때 필요한 메모리를 할당할 땐 힙 메모리에서 가져다 쓴다.
특별히 해제해주는 작업이 없다면 프로그램 내내 힙 메모리에 안정적으로 남아있게 된다.
C++ 에선 개발자가 반드시 직접 delete 로 일일이 해제 해주어 힙 메모리 누수를 막아야 했었다.
C# 에선 아무도 참조하지 않고 자리만 차지하는 힙 메모리는 C# 시스템 자체의 가비지 콜렉터가 알아서 해제해준다.
Call by Reference 를 실현하는 ref 변수가 참조하는 데이터는 스택 메모리일 수도 있다.
ref int a 에서 참조하는 메모리는 스택 메모리 일 수도 있는 것. a엔 참조 중인 스택 메모리의 주소가 스택 메모리에 속한 a에 올라가게 된다.
Call by Reference 라고 해서 무조건 힙에 저장되는건 아니라는 것이다. 착각하지 말기!
